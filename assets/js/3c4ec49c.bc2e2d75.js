"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[5358],{3905:function(e,t,n){n.d(t,{Zo:function(){return u},kt:function(){return h}});var i=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,r=function(e,t){if(null==e)return{};var n,i,r={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=i.createContext({}),c=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},u=function(e){var t=c(e.components);return i.createElement(l.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},p=i.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=c(n),h=r,f=p["".concat(l,".").concat(h)]||p[h]||d[h]||o;return n?i.createElement(f,a(a({ref:t},u),{},{components:n})):i.createElement(f,a({ref:t},u))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,a=new Array(o);a[0]=p;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,a[1]=s;for(var c=2;c<o;c++)a[c]=n[c];return i.createElement.apply(null,a)}return i.createElement.apply(null,n)}p.displayName="MDXCreateElement"},670:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return u},default:function(){return p}});var i=n(2122),r=n(9756),o=(n(7294),n(3905)),a=["components"],s={id:"highlights",title:"Main highlights"},l=void 0,c={unversionedId:"getting-started/highlights",id:"getting-started/highlights",isDocsHomePage:!1,title:"Main highlights",description:"Here is a list with main Centrifugo \u2728highlights\u2728. Every point is then extended throughout documentation.",source:"@site/docs/getting-started/highlights.md",sourceDirName:"getting-started",slug:"/getting-started/highlights",permalink:"/docs/getting-started/highlights",editUrl:"https://github.com/centrifugal/centrifugal.dev/edit/main/docs/getting-started/highlights.md",version:"current",frontMatter:{id:"highlights",title:"Main highlights"},sidebar:"Introduction",previous:{title:"Centrifugo introduction",permalink:"/docs/getting-started/introduction"},next:{title:"Install Centrifugo",permalink:"/docs/getting-started/installation"}},u=[{value:"Simple integration",id:"simple-integration",children:[]},{value:"Great performance",id:"great-performance",children:[]},{value:"Built-in scalability",id:"built-in-scalability",children:[]},{value:"Strict client protocol",id:"strict-client-protocol",children:[]},{value:"Variety of real-time transports",id:"variety-of-real-time-transports",children:[]},{value:"Flexible authentication",id:"flexible-authentication",children:[]},{value:"Connection management",id:"connection-management",children:[]},{value:"Channel (room) concept",id:"channel-room-concept",children:[]},{value:"Different types of subscriptions",id:"different-types-of-subscriptions",children:[]},{value:"RPC over bidirectional connection",id:"rpc-over-bidirectional-connection",children:[]},{value:"Presence information",id:"presence-information",children:[]},{value:"Message history in channels",id:"message-history-in-channels",children:[]},{value:"Embedded admin web UI",id:"embedded-admin-web-ui",children:[]},{value:"Cross-platform",id:"cross-platform",children:[]},{value:"Ready to deploy",id:"ready-to-deploy",children:[]},{value:"Open-source",id:"open-source",children:[]},{value:"Pro features",id:"pro-features",children:[]}],d={toc:u};function p(e){var t=e.components,n=(0,r.Z)(e,a);return(0,o.kt)("wrapper",(0,i.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Here is a list with main Centrifugo \u2728highlights\u2728. Every point is then extended throughout documentation."),(0,o.kt)("h3",{id:"simple-integration"},"Simple integration"),(0,o.kt)("p",null,"Since Centrifugo originally designed to be used in conjunction with frameworks without builtin concurrency support (like Django, Laravel etc.) it works as a standalone service with well-defined communication contracts. It fits very well both monolythic and microservice architecture. Application developers should not change backend phylosophy at all \u2013 just integrate with Centrifugo HTTP or GRPC API and let users enjoy real-time updates. "),(0,o.kt)("h3",{id:"great-performance"},"Great performance"),(0,o.kt)("p",null,"Centrifugo is pretty fast. It's written in Go language, uses fast open-source libraries internally, has some internal optimizations like message queuing on broadcasts, smart batching to reduce number of RTT with broker, connection hub sharding to avoid contention, JSON and Protobuf encoding speedups over code generation and other."),(0,o.kt)("p",null,"See a ",(0,o.kt)("a",{parentName:"p",href:"/blog/2020/02/10/million-connections-with-centrifugo"},"Million WebSocket with Centrifugo")," post in our blog to see some real-world numbers."),(0,o.kt)("h3",{id:"built-in-scalability"},"Built-in scalability"),(0,o.kt)("p",null,"Centrifugo can scale to many nodes with a help of PUB/SUB brokers. The main PUB/SUB engine Centrifugo integrates with is Redis. It supports client-side consistent sharding and Redis Cluster support so single Redis instance won't be a bottleneck. There are other options to scale: like KeyDB, Nats, Tarantool."),(0,o.kt)("h3",{id:"strict-client-protocol"},"Strict client protocol"),(0,o.kt)("p",null,"Centrifugo supports JSON and binary Protobuf protocol for client-server communication. Bidirectional protocol is defined by strict schema and there are several ready to use connectors that wrap this protocol, handle asynchronous message passing, timeouts, reconnect and various Centrifugo client API features."),(0,o.kt)("h3",{id:"variety-of-real-time-transports"},"Variety of real-time transports"),(0,o.kt)("p",null,"The main transport in Centrifugo is WebSocket. It's a bidirectional transport on top of TCP with low-overhead. For browsers which do not support WebSocket Centrifugo provides SockJS support."),(0,o.kt)("p",null,"Centrifugo v3 also introduced support for unidirectional transports for real-time updates: like SSE (Eventsource), HTTP streaming, GRPC unidirectional stream. Using unidirectional transport is sufficient for many real-time applications and does not require using custom client connectors \u2013 just native APIs or GRPC-generated code."),(0,o.kt)("h3",{id:"flexible-authentication"},"Flexible authentication"),(0,o.kt)("p",null,"Centrifugo can authenticate connections using JWT (JSON Web Tokens) or by issueing a HTTP/GRPC request to your application backend upon connection attempt. It's possible to proxy original request headers or request metadata (in case of GRPC connection). It supports JWK specification."),(0,o.kt)("h3",{id:"connection-management"},"Connection management"),(0,o.kt)("p",null,"Connections can expire, developers can choose a way on how to handle connection refresh \u2013 using client-side refresh workflow, or server-side call from Centrifugo to backend. "),(0,o.kt)("h3",{id:"channel-room-concept"},"Channel (room) concept"),(0,o.kt)("p",null,"Centrifugo is PUB/SUB server \u2013 users subscribe to channels to receive real-time updates. Message sent to a channel will be delivered to all active subscribers."),(0,o.kt)("p",null,"There are several different types of channels to deal with permissions. "),(0,o.kt)("h3",{id:"different-types-of-subscriptions"},"Different types of subscriptions"),(0,o.kt)("p",null,"Centrifugo is unique in terms of the fact it supports both client-side and server-side channel subscriptions."),(0,o.kt)("h3",{id:"rpc-over-bidirectional-connection"},"RPC over bidirectional connection"),(0,o.kt)("p",null,"You can fully utililize bidirectional persistent connections by sending RPC calls from client side to a configured endpoint on your backend. Calling RPC over WebSocket avoids sending headers on each request thus reducing external traffic. "),(0,o.kt)("h3",{id:"presence-information"},"Presence information"),(0,o.kt)("p",null,"It's possible to turn on presence feature for channels so you will have an information about active channels subscribers. Channel join and leave events (when user subscribes/unsubscribes) can also be sent."),(0,o.kt)("h3",{id:"message-history-in-channels"},"Message history in channels"),(0,o.kt)("p",null,"Optionally Centrifugo allows turning on history for publications in channels. This publication history has a limited size and retention period (TTL). With this history Centrifugo can help to survive mass reconnect scenario, clients can automatically recover missed messages from a cache thus reducing load on your main database. It's also possible to manually iterate over stream from a client or a server side."),(0,o.kt)("h3",{id:"embedded-admin-web-ui"},"Embedded admin web UI"),(0,o.kt)("p",null,"Built-in administrative web UI allows publishing messages to channels, looking at Centrifugo cluster state, monitoring stats etc."),(0,o.kt)("h3",{id:"cross-platform"},"Cross-platform"),(0,o.kt)("p",null,"Centrifugo works on Linux, MacOS and Windows."),(0,o.kt)("h3",{id:"ready-to-deploy"},"Ready to deploy"),(0,o.kt)("p",null,"Centrifugo supports various deploy ways: in Docker, using prepared RPM or DEB packages, via Kubernetes Helm chart. It supports automatic TLS with Let's Encrypt TLS, outputs Prometheus/Graphite metrics, has official Grafana dashboard for Prometheus data source."),(0,o.kt)("h3",{id:"open-source"},"Open-source"),(0,o.kt)("p",null,"Centrifugo is built on top of open-source library Centrifuge (MIT license), the OSS version of Centrifugo is based on permissive open-source license (Apache 2.0). All client connectors are also MIT-licensed."),(0,o.kt)("h3",{id:"pro-features"},"Pro features"),(0,o.kt)("p",null,"Centrifugo PRO extends Centrifugo with several unique features which can give interesting advantages for business adopters. "),(0,o.kt)("p",null,"With Centrifugo Pro it's possible to trace specific user or specific channel events in real-time. Centrifugo Pro integrates with ClickHouse for real-time connection analytics. This all may help with understanding client behaviour, inspect and analize an application on a very granular level."),(0,o.kt)("p",null,"Centrifugo Pro offers even more extensions tend to be useful on practice. This includes user active status and throttling features. Active status is useful to build messenger-like applications where you want to show online indicators of users based on last activity time, throttling can help you limit number of operations each user may execute on Centrifugo cluster."),(0,o.kt)("p",null,"For additional details, refer to the ",(0,o.kt)("a",{parentName:"p",href:"../pro/overview"},"Centrifugo PRO documentation"),"."))}p.isMDXComponent=!0}}]);