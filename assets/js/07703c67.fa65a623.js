"use strict";(self.webpackChunkcentrifugal_dev=self.webpackChunkcentrifugal_dev||[]).push([[1658],{3905:function(e,t,n){n.d(t,{Zo:function(){return d},kt:function(){return m}});var r=n(7294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function a(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):a(a({},t),e)),n},d=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),u=c(n),m=o,h=u["".concat(l,".").concat(m)]||u[m]||p[m]||i;return n?r.createElement(h,a(a({ref:t},d),{},{components:n})):r.createElement(h,a({ref:t},d))}));function m(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var i=n.length,a=new Array(i);a[0]=u;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,a[1]=s;for(var c=2;c<i;c++)a[c]=n[c];return r.createElement.apply(null,a)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},1428:function(e,t,n){n.r(t),n.d(t,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return d},default:function(){return u}});var r=n(2122),o=n(9756),i=(n(7294),n(3905)),a=["components"],s={id:"history_and_recovery",title:"History and recovery"},l=void 0,c={unversionedId:"server/history_and_recovery",id:"server/history_and_recovery",isDocsHomePage:!1,title:"History and recovery",description:"Centrifugo engines can maintain publication stream with configured size and TTL.",source:"@site/docs/server/history_and_recovery.md",sourceDirName:"server",slug:"/server/history_and_recovery",permalink:"/docs/server/history_and_recovery",editUrl:"https://github.com/centrifugal/centrifugal.dev/edit/main/docs/server/history_and_recovery.md",version:"current",frontMatter:{id:"history_and_recovery",title:"History and recovery"},sidebar:"Guides",previous:{title:"Proxy to backend",permalink:"/docs/server/proxy"},next:{title:"Admin web UI",permalink:"/docs/server/admin_web"}},d=[{value:"History design",id:"history-design",children:[]},{value:"History iteration API",id:"history-iteration-api",children:[]},{value:"Automatic message recovery",id:"automatic-message-recovery",children:[]}],p={toc:d};function u(e){var t=e.components,n=(0,o.Z)(e,a);return(0,i.kt)("wrapper",(0,r.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Centrifugo engines can maintain publication stream with configured size and TTL."),(0,i.kt)("h2",{id:"history-design"},"History design"),(0,i.kt)("p",null,"History properties configured on a namespace level, to enable history both ",(0,i.kt)("inlineCode",{parentName:"p"},"history_size")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"history_ttl")," should be set to a value greater than zero. "),(0,i.kt)("p",null,"Centrifugo is not designed to keep publications streams forever. Streams are ephemeral and can expire or can be lost at any moment. But Centrifugo provides a way for an application or a client to understand that stream history lost. In this case main application database should be the source of truth and state recovery."),(0,i.kt)("p",null,"When history is on every publication published into a channel saved into a history. Depending on engine used history stream implementation can differ. For example, in case of Memory engine all history stored in process memory. So as soon as Centrifugo restarted all history is cleared. When using Redis engine history is kept in Redis Stream data structure - persistence properties is then inherited from Redis persistence configuration (the same for KeyDB engine). For Tarantool history is kept inside spaces."),(0,i.kt)("p",null,"Each publication when added to history has ",(0,i.kt)("inlineCode",{parentName:"p"},"offset")," field. This is an incremental ",(0,i.kt)("inlineCode",{parentName:"p"},"uint64")," field. Each stream identified by ",(0,i.kt)("inlineCode",{parentName:"p"},"epoch")," field - which is arbitrary string. As soon as underlying engine looses data epoch field will change for a stream thus letting consumers know that stream can't be used as source of truth anymore."),(0,i.kt)("h2",{id:"history-iteration-api"},"History iteration API"),(0,i.kt)("p",null,"Coming soon."),(0,i.kt)("h2",{id:"automatic-message-recovery"},"Automatic message recovery"),(0,i.kt)("p",null,"One of the most interesting features of Centrifugo is automatic message recovery after short network disconnects. This mechanism allows client to automatically restore missed publications on successful resubscribe to a channel after being disconnected for a while."),(0,i.kt)("p",null,"In general, you could query your application backend for actual state on every client reconnect - but message recovery feature allows Centrifugo to deal with this and restore missed publications from history cache thus radically reducing load on your application backend and your main application database in some scenarios (when many clients reconnect at the same time)."),(0,i.kt)("div",{className:"admonition admonition-danger alert alert--danger"},(0,i.kt)("div",{parentName:"div",className:"admonition-heading"},(0,i.kt)("h5",{parentName:"div"},(0,i.kt)("span",{parentName:"h5",className:"admonition-icon"},(0,i.kt)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},(0,i.kt)("path",{parentName:"svg",fillRule:"evenodd",d:"M5.05.31c.81 2.17.41 3.38-.52 4.31C3.55 5.67 1.98 6.45.9 7.98c-1.45 2.05-1.7 6.53 3.53 7.7-2.2-1.16-2.67-4.52-.3-6.61-.61 2.03.53 3.33 1.94 2.86 1.39-.47 2.3.53 2.27 1.67-.02.78-.31 1.44-1.13 1.81 3.42-.59 4.78-3.42 4.78-5.56 0-2.84-2.53-3.22-1.25-5.61-1.52.13-2.03 1.13-1.89 2.75.09 1.08-1.02 1.8-1.86 1.33-.67-.41-.66-1.19-.06-1.78C8.18 5.31 8.68 2.45 5.05.32L5.03.3l.02.01z"}))),"danger")),(0,i.kt)("div",{parentName:"div",className:"admonition-content"},(0,i.kt)("p",{parentName:"div"},"Message recovery protocol feature designed to be used together with reasonably small Publication stream size as all missed publications sent towards client in one protocol frame on resubscribe to a channel. Thus, it mostly suitable for short-time disconnects. It helps a lot to survive reconnect storm when many clients reconnect at one moment (balancer reload, network glitch) - but it's not a good idea to recover a long list of missed messages after clients being offline for a long time."))),(0,i.kt)("p",null,"To enable recovery mechanism for channels set ",(0,i.kt)("inlineCode",{parentName:"p"},"recover")," boolean configuration option to ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," on the configuration file top-level or for a channel namespace. Make sure to enable this option in namespaces where history is on."),(0,i.kt)("p",null,"When re-subscribing on channels Centrifugo will return missed ",(0,i.kt)("inlineCode",{parentName:"p"},"publications")," to client in subscribe ",(0,i.kt)("inlineCode",{parentName:"p"},"Reply"),", also it will return special ",(0,i.kt)("inlineCode",{parentName:"p"},"recovered")," boolean flag to indicate whether all missed publications successfully recovered after disconnect or not."),(0,i.kt)("p",null,"Centrifugo recovery model based on two fields in protocol: ",(0,i.kt)("inlineCode",{parentName:"p"},"offset")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"epoch"),". All fields managed automatically by Centrifugo client libraries (for bidirectional transport), but it's good to know how recovery works under the hood."),(0,i.kt)("p",null,"Recovery feature heavily relies on ",(0,i.kt)("inlineCode",{parentName:"p"},"offset")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"epoch")," values descrbed above."),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"epoch")," handles cases when history storage has been restarted while client was in disconnected state so publication numeration in a channel started from scratch. For example at moment Memory engine does not persist publication sequences on disk so every restart will start numeration from scratch, after each restart new ",(0,i.kt)("inlineCode",{parentName:"p"},"epoch")," field generated, and we can understand in recovery process that client could miss messages thus returning correct ",(0,i.kt)("inlineCode",{parentName:"p"},"recovered")," flag in subscribe ",(0,i.kt)("inlineCode",{parentName:"p"},"Reply"),". This also applies to Redis engine \u2013 if you do not use AOF with fsync then sequences can be lost after Redis restart. When using Redis engine you need to use fully in-memory model strategy or AOF with fsync to guarantee reliability of ",(0,i.kt)("inlineCode",{parentName:"p"},"recovered")," flag sent by Centrifugo."),(0,i.kt)("p",null,"When server receives subscribe command with boolean flag ",(0,i.kt)("inlineCode",{parentName:"p"},"recover")," set to ",(0,i.kt)("inlineCode",{parentName:"p"},"true")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"offset"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"epoch")," set to values last seen by a client (see ",(0,i.kt)("inlineCode",{parentName:"p"},"SubscribeRequest")," type in ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/centrifugal/protocol/blob/master/definitions/client.proto"},"protocol definitions"),") it will try to find all missed publications from history cache. Recovered publications will be passed to client in subscribe ",(0,i.kt)("inlineCode",{parentName:"p"},"Reply")," in correct order, so your publication handler will be automatically called to process each missed message."),(0,i.kt)("p",null,"You can also manually implement your own recovery algorithm on top of basic PUB/SUB possibilities that Centrifugo provides. As we said above you can simply ask your backend for an actual state after every client reconnect completely bypassing recovery mechanism described here. Also it's possible to manually iterate over Centrifugo stream using history iteration API described above."))}u.isMDXComponent=!0}}]);